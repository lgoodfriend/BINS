\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{float}
\usepackage{epstopdf}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{sidecap}
\usepackage{subfig}
\usepackage{ulem}
\usepackage{color}
\usepackage{placeins}
\usepackage[dvips,letterpaper,margin=1in]{geometry} %for one inch margins
\author{Lauren Goodfriend}
\title{Guide to the BINS educational solver}
\begin{document}
\maketitle
\tableofcontents

%----------------------------------------------------------------------
\section{Introduction}
%----------------------------------------------------------------------

The Basic Incompressible Navier-Stokes (BINS) solver is designed to be an educational tool for learning how to solve the incompressible Navier-Stokes equation with finite differences.  A gap exists between the basic numerical methods learned in a numerical partial differential equations class and the complexity of full Navier-Stokes research codes.  BINS is intended to form a bridge for engineering students who have some knowledge of numerical methods, but are unsure how to combine them into a working Navier-Stokes solver.  It may also be useful for students wrestling with an enormous research code for the first time, as a reference for the essential processes underlying most finite difference physical Navier-Stokes solvers.

%----------------------------------------------------------------------
\section{Getting started}
%----------------------------------------------------------------------

BINS is written in Matlab/Octave, so you will need one of those interpreters to run the code.  Octave is a free, open-source language that is very similar to Matlab.  You can learn about it at \texttt{www.gnu.org/software/octave}.

The first step is to download the code tarball from \[ \texttt{https://github.com/lgoodfriend/BINS/downloads}\]  After you've downloaded and untarred the tarball, you should see a folder with a bunch of files in it.  The key file for getting started is \texttt{intro.m}.

Start a Matlab/Octave session and type \texttt{intro} at the prompt.  You should see two figures appear (Figure~\ref{vel_init}).  These represent the solution to the Taylor-Green vortex after 1 second.  You can change some aspects of how the code runs by changing the inputs to the function \texttt{BINS} in the file \texttt{intro.m}.

\begin{center}
\begin{figure*}
\center
\subfloat[u velocity]{\label{u_init}\includegraphics[width=0.48\textwidth]{u_init.png} 
}  
\subfloat[v velocity]{\label{v_init}\includegraphics[width=0.48\textwidth]{v_init.png} 
} 
\caption{Results of running \texttt{intro.m}}
\label{vel_init}
\end{figure*}
\end{center}

\subsection{Changing the domain}
The domain size is controlled by \texttt{N} and \texttt{L}.  \texttt{N} sets the number of cells in each direction, and \texttt{L} sets the physical length of each dimension.

\subsection{Changing the boundary conditions}
The boundary conditions are controlled by \texttt{BC}.  \texttt{BC} is a vector with entries corresponding to tags marking the choice of boundary condition:
\[ \texttt{BC} = [\mathrm{lower \hspace{2pt} x, upper\hspace{2pt} x, lower\hspace{2pt} y, upper\hspace{2pt} y} ]\]

BINS has two kinds of boundary conditions
\begin{itemize}
\item periodic
\item moving, impermeable, no-slip wall
\end{itemize}

The periodic boundary conditions are tagged with $\sqrt{-1}$, and the wall boundary conditions are tagged with the velocity of the wall.  Thus, if you wanted an all periodic domain, you would set
\[ \texttt{BC = [sqrt(-1),sqrt(-1),sqrt(-1),sqrt(-1)]}\]
If you wanted the $x$ boundaries to be periodic, with fixed walls on the $y$ boundaries (making an infinite channel), you would set
\[ \texttt{BC = [sqrt(-1),sqrt(-1),0,0]}\]
If you wanted to make a cavity forced by a lid moving at speed $U$ on the upper $y$ boundary, you would set
\[ \texttt{BC = [0,0,0,U]}\]

\subsection{Changing the initial condition}
The initial condition is controlled by \texttt{IC\_choice}, which indexes to an initial condition listed in \texttt{IC.m}.  The available initial conditions are 
\begin{enumerate}
\item $u$ = 0, $v$ = 0, $p$ = 0
\item $u$ = 1, $v$ = 1, $p$ = 0
\item Taylor-Green vortex
\item shear flow
\end{enumerate}
You can add a new initial condition by editing \texttt{IC.m} to include the initial condition you would like.  If you are setting a new initial condition, it is important to understand how the staggered grid is set up (see section~\ref{staggeredGrid}).

%----------------------------------------------------------------------
\section{Underlying mathematics}
%----------------------------------------------------------------------
\subsection{Notation}
We use index notation for brevity when discussing the Navier-Stokes equation.  The variable $x_i$ represents the spatial dimensions
\[ x_1 = x\]
\[ x_2 = y\] 
and $u_i$ represents the velocity components
\[ u_1 = u = \mathrm{velocity\ in\ x\ direction}\]
\[ u_2 = v = \mathrm{velocity\ in\ y\ direction}\]

Superscripts are used to denote the numerical timestep.  The variable $u^n$ represents the numerical value of $u$ at timestep $n$, or time $t=n\Delta t$.

\subsection{Solving the Navier-Stokes equation}
\label{mathBasics}

We want to solve the incompressible Navier-Stokes equation
\begin{align*}
  \left. \underbrace{\frac{\partial u_i}{\partial t}}_\textrm{time} +  \underbrace{\frac{\partial u_i u_j}{\partial x_j}}_\textrm{advection} = \underbrace{- \frac{1}{\rho}\frac{\partial p}{\partial x_i}}_\textrm{pressure} + \underbrace{\nu \frac{\partial^2 u_i}{\partial x_j \partial x_j}}_\textrm{diffusion} \right\} &\textrm{momentum conservation} \\
\left. \frac{\partial u_i}{\partial x_i} = 0 \right\} &\textrm{mass conservation}
\end{align*}

The code first estimates the solution to the Navier-Stokes equation using only the advection and diffusion terms. 
\begin{equation}
 \frac{\partial u_i^*}{\partial t} =   -\frac{\partial u_i^n u_j^n}{\partial x_j} + \nu \frac{\partial^2 u_i^n}{\partial x_j \partial x_j} 
 \label{predict}
\end{equation}
The superscript $*$ denotes that the velocity calculated in this step $u^*$ is temporary and doesn't exist at a timestep.

The code then projects the intermediate velocity field $u_i^*$ onto a divergence-free space using the next time step pressure $p^{n+1}$ calculated by
\begin{equation}
\nabla^2 p^{n+1} = \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i}
\label{poisson}
\end{equation}

Then we can find the new divergence free velocity field $u_i^{n+1}$ 

\begin{equation}
u_i^{n+1}= u_i^* - \Delta t\frac{\partial p^{n+1}}{\partial x_i}
\label{correct}
\end{equation}

since
\begin{align*}
\frac{\partial  u_i^{n+1}}{\partial x_i} &= \frac{\partial}{\partial x_i}\left(u_i^* - \Delta t\frac{\partial p^{n+1}}{\partial x_i} \right) \\
&= \frac{\partial u_i^*}{\partial x_i} - \Delta t\nabla^2p^{n+1} \\
&= 0 \\
\end{align*}

These steps appear in the functions in the file \texttt{advance.m}.  In the $\texttt{predict}$ function, the next time step velocity is estimated following equation~\ref{predict}.  This step uses the advection and diffusion terms, calculated in subroutines \texttt{advection} and \texttt{diffusion} respectively.  The poisson equation for pressure in equation~\ref{poisson} is solved in the function $\texttt{pressure}$.  The next time step velocity is then calculated by correcting the predicted velocity in function \texttt{correct}, as in equation~\ref{correct}.  These steps are outlined below.

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
advection term & \Large{$\frac{\partial u_i u_j}{\partial x_j}$} & \texttt{advection} & \texttt{advance.m}\\ 
\hline 
diffusion term & \Large{$\nu \frac{\partial^2 u_i}{\partial x_j \partial x_j}$} & \texttt{diffusion} & \texttt{advance.m} \\ 
\hline 
next time step: velocity prediction & \Large{$ \frac{\partial u_i^*}{\partial t} =   -\frac{\partial u_i^n u_j^n}{\partial x_j} + \nu \frac{\partial^2 u_i^n}{\partial x_j \partial x_j} $} & \texttt{predict}& \texttt{advance.m} \\ 
\hline 
next time step: pressure & \Large{$\nabla^2 p^{n+1} = \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i}$} & \texttt{pressure} & \texttt{advance.m}\\ 
\hline 
next time step: velocity & \Large{$u_i^{n+1}= u_i^* - \Delta t\frac{\partial p^{n+1}}{\partial x_i}$} & \texttt{correct}& \texttt{advance.m} \\ 
\hline 
\end{tabular} 
\end{center}

\subsection{Finite differences}

To approximate a partial differential equation on the computer, we use finite differences to estimate derivatives.  By default, BINS uses first-order forward Euler time stepping and second-order differences in space.

\subsubsection{Time stepping}
The time stepping in BINS is done using forward Euler time stepping.  If we want to approximate 
\[ \frac{\partial u}{\partial t} = f(u,t) \]
we use the simple approximation
\[ \frac{u^{n+1}-u^n}{\Delta t} = f(u^n,t^n)\]

This allows us to calculate $u$ at the next timestep as
\begin{equation}
u^{n+1} = u^n + \Delta t f(u^n,t^n)
\end{equation}

We use these time stepping routines in the \texttt{predict} function to estimate the next time step velocity using the advection and diffusion terms, without accounting for pressure.  So in BINS
\[ f(u,t) = -\frac{\partial u_i u_j}{\partial x_j} + \nu \frac{\partial^2 u_i}{\partial x_j \partial x_j} \]

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
time step & \Large{$\frac{\partial u_i}{\partial t}$} & \texttt{predict}& \texttt{advance.m} \\ 
\hline 
\end{tabular} 
\end{center}

\subsubsection{Spatial derivatives}
To solve the Navier-Stokes equation, we need to calculate first and second derivatives.  BINS uses centered finite differences for all these calculations.  First derivatives are approximated as
\begin{equation}
\label{firstDeriv}
\frac{\partial u}{\partial x} = \frac{u_{i+1} - u_{i}}{\Delta x}
\end{equation}
and second derivatives as
\begin{equation}
\label{secondDeriv}
\frac{\partial^2 u}{\partial x^2} = \frac{u_{i+1} -2 u_i + u_{i+1}}{\Delta x^2}
\end{equation}
Here (just to be confusing!), $u_i$ represents the numerical value of the variable $u$ at spatial gridpoint $i$, so $u_i=u(i\Delta x)$.  

Subroutines to calculate spatial derivatives are found in the file \texttt{calculus.m}.  BINS has a different function for each first derivative used, because the staggered grid makes the indexing for each derivative slightly different.  This first derivative ends up being second-order because of the staggered grid. For details on how the first derivatives are implemented, see section~\ref{staggeredGrid}.

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
first derivative: advection term & \Large{$\frac{\partial uu}{\partial x}$} & \texttt{adv\_duudx} & \texttt{calculus.m}\\ 
\hline 
first derivative: advection term & \Large{$\frac{\partial uv}{\partial y}$} & \texttt{adv\_duvdy} & \texttt{calculus.m}\\ 
\hline 
first derivative: advection term & \Large{$\frac{\partial vu}{\partial x}$} & \texttt{adv\_dvudx} & \texttt{calculus.m}\\ 
\hline 
first derivative: advection term & \Large{$\frac{\partial vv}{\partial y}$} & \texttt{adv\_dvvdy} & \texttt{calculus.m}\\ 
\hline 
first derivative: pressure correction & \Large{$\frac{\partial p}{\partial x}$} & \texttt{correct\_dpdx} & \texttt{calculus.m}\\ 
\hline
first derivative: pressure correction & \Large{$\frac{\partial p}{\partial y}$} & \texttt{correct\_dpdy} & \texttt{calculus.m}\\ 
\hline
first derivative: divergence & \Large{$\frac{\partial u}{\partial x} + \frac{\partial v}{\partial y}$} & \texttt{divergence} & \texttt{calculus.m}\\ 
\hline
second derivative & \Large{$\frac{\partial^2 u}{\partial x^2}$} & \texttt{secondDeriv} & \texttt{calculus.m}\\ 
\hline 
\end{tabular} 
\end{center}

\subsection{Solving the Poisson equation}
As we saw in section~\ref{mathBasics}, we must solve a Poisson equation to find the pressure at the next timestep (equation~\ref{poisson}):
\[\nabla^2 p^{n+1} = \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i} \]

Solving a finite difference Poisson equation is actually inverting a matrix.  To see this, we first write the Poisson equation as a finite difference:
\begin{align*}
\nabla^2 p^{n+1} &= \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i} \\
\frac{p_{i+1j}-2p_{ij}+p_{i-1j}}{\Delta x^2} + \frac{p_{ij+1}-2p_{ij}+p_{ij-1}}{\Delta y^2} &= f_{ij}  \\
\end{align*}

Here, $p_{ij} = p(i\Delta x, j\Delta y)$. We've dropped the superscripts indicating timestep and written the right hand side as $f_{ij}$.  Remember that we know $f_{ij}$ and we need to solve for $p_{ij}$.  Assuming $\Delta x = \Delta y$,
\begin{align*}
\frac{p_{i+1j}-2p_{ij}+p_{i-1j}}{\Delta x^2} + \frac{p_{ij+1}-2p_{ij}+p_{ij-1}}{\Delta x^2} &= f_{ij}  \\
p_{i+1j}-4p_{ij}+p_{i-1j}+ p_{ij+1}+p_{ij-1} &= \Delta x^2 f_{ij}  \\
\end{align*}

By transforming the matrix $p_{ij}$ into a vector, we can convert this into a matrix equation.  For example, consider solving the Poisson equation on a $3 \times 3$ grid:
\begin{center}
\includegraphics[width=0.5\textwidth]{pgrid.png} 
\end{center}

Write the vector p as
\[ p^{T} = [p_{11}, p_{12}, p_{13}, p_{21}, p_{22}, p_{23}, p_{13}, p_{23}, p_{33}]\]

The row for $p_{22}$ is the simplest, since only points inside the domain are needed to calculate second derivatives at the central point.
\[ \left[ \begin{array}{c c c c c c c c c} \\ \\ \\ \\ 0&1&0&1&-4&1&0&1&0 \\ \\ \\ \\ \\ \end{array} \right] \left[ \begin{array}{c} p_{11}\\p_{12}\\p_{13}\\p_{21}\\p_{22}\\p_{23}\\p_{31}\\p_{32}\\p_{33}\\ \end{array}\right] = \left[ \begin{array}{c} f_{11}\\f_{12}\\f_{13}\\f_{21}\\f_{22}\\f_{23}\\f_{31}\\f_{32}\\f_{33}\\ \end{array}\right]
\]
For all the other points, we know some information, but other information must be filled in using boundary conditions.  If we just filled in the matrix using the finite difference formula as much as possible, we would find
\[ \left[ \begin{array}{c c c c c c c c c} 
-4&1&0&1&0&0&0&0&0\\ 
1&-4&1&0&1&0&0&0&0\\ 
0&1&-4&0&0&1&0&0&0\\ 
1&0&0&-4&1&0&1&0&0\\ 
0&1&0&1&-4&1&0&1&0 \\ 
0&0&1&0&1&-4&0&1&0\\ 
0&0&0&1&0&0&-4&1&0\\ 
0&0&0&0&1&0&1&-4&1\\ 
0&0&0&0&0&1&0&1&-4\\ \end{array} \right] \left[ \begin{array}{c} p_{11}\\p_{12}\\p_{13}\\p_{21}\\p_{22}\\p_{23}\\p_{31}\\p_{32}\\p_{33}\\ \end{array}\right] = \left[ \begin{array}{c} f_{11}\\f_{12}\\f_{13}\\f_{21}\\f_{22}\\f_{23}\\f_{31}\\f_{32}\\f_{33}\\ \end{array}\right]
\]

This matrix equation is incorrect because it does not enforce boundary conditions\footnote{In fact, it does not form a true finite difference approximation to derivatives, since the rows do not all sum to 1.}. For all but the center point, we need boundary conditions to calculate the Laplacian.  

For example, if the boundary conditions are periodic (see section~\ref{periodicBCs}), then $p_{12}$ is adjacent to $p_{32}$, $p_{21}$ is adjacent to $p_{23}$, etc.  Then the matrix is
\[ \left[ \begin{array}{c c c c c c c c c} 
-4&1&1&1&0&0&1&0&0\\ 
1&-4&1&0&1&0&0&1&0\\ 
1&1&-4&0&0&1&0&0&1\\ 
1&0&0&-4&1&1&1&0&0\\ 
0&1&0&1&-4&1&0&1&0 \\ 
0&0&1&1&1&-4&0&1&0\\ 
1&0&0&1&0&0&-4&1&1\\ 
0&1&0&0&1&0&1&-4&1\\ 
0&0&1&0&0&1&1&1&-4\\ \end{array} \right] \left[ \begin{array}{c} p_{11}\\p_{12}\\p_{13}\\p_{21}\\p_{22}\\p_{23}\\p_{31}\\p_{32}\\p_{33}\\ \end{array}\right] = \left[ \begin{array}{c} f_{11}\\f_{12}\\f_{13}\\f_{21}\\f_{22}\\f_{23}\\f_{31}\\f_{32}\\f_{33}\\ \end{array}\right]
\]
We can then solve for the pressure by solving this matrix equation
\[ Ap = f\]
which has solution
\[ p = A^{-1}f\]
In BINS, the matrix $A$ and vector $f$ are formed in \texttt{make\_matrix.m}, and the solution is found in \texttt{solvePoisson.m}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
matrix defining Laplacian & $A$ & \texttt{make\_matrix} & \texttt{make\_matrix.m}\\ 
\hline 
vector defining Poisson forcing & $f$ & \texttt{make\_matrix} & \texttt{make\_matrix.m}\\ 
\hline 
solution to Poisson equation & $p = A^{-1}f$ & \texttt{solvePoisson} & \texttt{solvePoisson.m}\\ 
\hline 
\end{tabular} 
\end{center}

\subsubsection{Inverting a matrix}
Solving the Poisson equation requires inverting a matrix.  Gaussian elimination can invert a matrix, but this algorithm is expensive, in that it takes a lot of computational time.  Many shortcuts have been developed to invert matrices quickly.  These shortcuts often do not solve the inversion exactly, which is ok, because we are only approximating the solution to the Navier-Stokes equations anyway.

This version of BINS uses Matlab/Octave's built in matrix inversion function \texttt{backslash}, also written ``\textbackslash''.  This is admittedly a crutch, but it's a very nice crutch.  Both Matlab and Octave have sparse matrix functions built in, which makes inverting sparse matrices like $A$ very fast.  Solving the Poisson equation is usually the slowest part of a Navier-Stokes solver.

%----------------------------------------------------------------------
\section{Specifics of the computation}
%----------------------------------------------------------------------
\FloatBarrier
\subsection{Staggered grid}
\label{staggeredGrid}
In a standard numerical grid, all the variables are located at cell centers (Figure~\ref{collocated}).  This arrangement is simple to code, but it is not commonly used in Navier-Stokes solvers.  A staggered grid (Figure~\ref{staggered}) is more natural for solving the Navier-Stokes equation, because it increases the order of accuracy of the spatial derivatives involved in solving for the pressure\footnote{This is an oversimplification.  If you want to know the details, look at F\&P}.

\begin{center}
\begin{figure*}
\center
\subfloat[Collocated grid]{\label{collocated}\includegraphics[width=0.33\textwidth]{colocated.png} 
}  
\subfloat[Staggered grid]{\label{staggered}\includegraphics[width=0.33\textwidth]{staggered.png} 
} 
\caption{Different types of variable centering on a grid.}
\label{grid_types}
\end{figure*}
\end{center}

\FloatBarrier
The staggered grid means that each of the four derivatives needed in the advective terms are slightly different.  The $x$-direction advective terms is defined on the left side of cells, at the same point as $u$ (Figure~\ref{staggered}).  To calculate the $\frac{\partial uu}{\partial x}$ term, we can first average $u$ to cell centers, and the take the derivative at the left cell face (Figure~\ref{duudx}).  Similarly, to calculate $\frac{\partial uv}{\partial y}$, we average $u$ and $v$ to cell corners, and then take the derivative at the left cell face (Figure~\ref{duvdy}).  A similar averaging procedure is used for the $y$-direction advection terms (Figure~\ref{y_adv}). 


\FloatBarrier
\begin{center}
\begin{figure*}
\center
\subfloat[$\frac{\partial uu}{\partial x}$]{\label{duudx}\includegraphics[width=0.33\textwidth]{duudx.png} 
}  
\subfloat[$\frac{\partial uv}{\partial y}$]{\label{duvdy}\includegraphics[width=0.33\textwidth]{duvdy.png} 
} 
\caption{First derivatives for $x$ direction advection term.}
\label{x_adv}
\end{figure*}
\end{center}

\begin{center}
\begin{figure*}
\center
\subfloat[$\frac{\partial vu}{\partial x}$]{\label{dvudx}\includegraphics[width=0.33\textwidth]{dvudx.png} 
}  
\subfloat[$\frac{\partial vv}{\partial y}$]{\label{dvvdy}\includegraphics[width=0.33\textwidth]{dvvdy.png} 
} 
\caption{First derivatives for $x$ direction advection term.}
\label{y_adv}
\end{figure*}
\end{center}

The derivatives needed for the divergence-free / pressure solve are relatively simple.  The divergence is needed at cell centers, which is naturally second-order with face-centered velocities (Figure~\ref{div}). Similarly, the pressure derivatives needed at cell faces are naturally second-order with cell-centered pressure (Figure~\ref{dpdx}).

\begin{center}
\begin{figure*}
\center
\subfloat[divergence]{\label{div}\includegraphics[width=0.33\textwidth]{div.png} 
}  
\subfloat[pressure derivatives]{\label{dpdx}\includegraphics[width=0.33\textwidth]{dpdx.png} 
} 
\caption{First derivatives for the divergence-free / pressure solve.}
\label{pressDeriv}
\end{figure*}
\end{center}



\FloatBarrier
\subsection{Boundary conditions}
When we want to calculate a first derivative of $u_i$ ($u$ at grid point $i$), we require $u_{i+1}$.  If $u_i$ is on an upper boundary, we need to know what to use for $u_{i+1}$ in equation~\ref{firstDeriv}.  The same is true for calculating a second derivative in equation~\ref{secondDeriv}.

BINS uses two kinds of boundary conditions: periodic and moving wall.  Boundary conditions are implemented using "ghost cells" (Figure~\ref{ghostcells}).  Ghost cells are points which lie outside the real solution domain, but are needed to calculate derivatives at the boundaries.  The solution is calculated on the inner domain, and then ghost cells are filled so that derivatives can be taken in the next time step.  Boundary conditions are enforced in \texttt{BCfill.m}.

\begin{center}
\begin{figure*}
\center
\includegraphics[width=0.48\textwidth]{ghostcell.png} 
\caption{Ghostcells outside the boundary of the domain.}
\label{ghostcells}
\end{figure*}
\end{center}

\subsubsection{Periodic boundary condition}
\label{periodicBCs}
A periodic boundary condition states that opposite edges of the domain are adjacent (Figure~\ref{torus}).  It is called "periodic" because this boundary condition causes the solution to repeat infinitely, so it becomes periodic with a period equal to the length of the domain.
\begin{center}
\begin{figure*}
\center
\includegraphics[width=0.48\textwidth]{torus.png} 
\caption{Schematic of periodic domain.}
\label{torus}
\end{figure*}
\end{center}

To implement this boundary condition, the solution at the right edge of the domain is copied to the ghost cells on the left edge of the domain, and vice-versa (Figure~\ref{pBC}).
\begin{center}
\begin{figure*}
\center
\includegraphics[width=0.48\textwidth]{periodic_BCs.png} 
\caption{How to fill periodic BCs.}
\label{pBC}
\end{figure*}
\end{center}  

\subsubsection{Moving wall boundary condition}
A moving wall boundary condition states that the boundary is an impermeable wall that is moving parallel to itself (Figure~\ref{movingwall}).  It can also be a stationary wall by setting the wall velocity to zero.
\begin{center}
\begin{figure*}
\center
\includegraphics[width=0.48\textwidth]{movingwall.png} 
\caption{Schematic of moving wall domain.}
\label{movingwall}
\end{figure*}
\end{center}


Unlike for the periodic boundary condition, the moving wall boundary condition must treat the two velocities and pressure differently (Figure~\ref{movingwall_loc}).  The velocity perpendicular to the wall must be zero at the wall, otherwise fluid would be moving into the wall.  The velocity parallel to the wall must be equal to the wall's velocity at the wall to satisfy the no-slip condition.  The derivative of the pressure perpendicular to the wall must be zero at the wall, otherwise the pressure would generate a force moving fluid into the wall.
\begin{center}
\begin{figure*}
\center
\includegraphics[width=0.48\textwidth]{movingwall_loc.png} 
\caption{Schematic of moving wall boundary condition locations.}
\label{movingwall_loc}
\end{figure*}
\end{center}

\begin{center}
\begin{figure*}
\center
\includegraphics[width=0.48\textwidth]{movingwall_BC.png} 
\caption{Schematic of moving wall boundary condition interpolation.}
\label{movingwall_BC}
\end{figure*}
\end{center}

The way we structured the grid means that we can set the velocity perpendicular to the wall to be equal to zero, because that velocity has a grid point on the wall (Figure~\ref{movingwall_BC}).  The velocity parallel to the wall does not have a grid point on the wall, so we need to interpolate. We have chosen to use a linear interpolation, so we require
\[ \frac{u_1 + u_{\mathrm{ghost}}}{2} = U_{\mathrm{wall}}\]
which means that
\begin{equation}
u_{\mathrm{ghost}} = 2U_{\mathrm{wall}} - u_1
\end{equation}
To set the pressure, we use the approximation to the first derivative in equation~\ref{firstDeriv}, and require
\[ \frac{p_1 - p_{\mathrm{ghost}}}{dx} = 0\]
which means that
\begin{equation}
p_{\mathrm{ghost}} = p_1
\end{equation}

%----------------------------------------------------------------------
\section{BINS reference: by function name}
%----------------------------------------------------------------------
This section provides a function-by-function breakdown of the components that make BINS work.

\includegraphics[width=\textwidth]{callGraph.png} 

\subsection{\texttt{advectionTerm}}
This function estimates the advection term of the Navier Stokes equation.

\subsection{\texttt{BINS}}
The main function is \texttt{BINS}, located in \texttt{BINS.m}.  It takes...  It calls the functions needed to advance the solution in time.

%----------------------------------------------------------------------
\section{BINS reference: by filename}
%----------------------------------------------------------------------
This section provudes a file-by-file breakdown of the components that make BINS work.

\subsection{\texttt{advance.m}}
This file contains the functions needed to advance the solution in time.

\subsection{\texttt{BINS.m}}
This file contains only one function, \texttt{BINS}, the main function of BINS.

%----------------------------------------------------------------------
\section{Known limitations/bugs}
%----------------------------------------------------------------------
\begin{itemize}
\item Code assumes $\Delta x=\Delta y$
\item Code requires $L_x = L_y$ and $N_x = N_y$
\item Multigrid doesn't work correctly yet
\item Only rectangular domains can be used
\item convergence test should include $v$ in the error
\item moving wall BC not thoroughly checked
\item errors near boundaries: BC filling bug?
\end{itemize}

%----------------------------------------------------------------------
\section{Validation}
%----------------------------------------------------------------------
We have validated BINS using the Taylor-Green vortex.  This solution is excellent for validating 2D, incompressible Navier-Stokes solvers because it is time-varying , with a fairly complex structure, but still has an exact solution.  
The exact solution on a periodic domain of dimension $[0,2\pi] \times [0,1\pi]$ is
\[ u=\sin (x) \cos (y) F(t)\]
\[ v=-\cos (x) \sin (y) F(t)\]
\[ F(t)=e^{-2\nu t}\]

\subsection{Comparison with exact solution}
For a first check, we can look at the difference between the numerical and exact solution (Figure~\ref{error}).  These plots show that most of the error is small, about 5\% of the maximum function value (which is 1).  The concentration of error near the boundaries suggests a guardcell error.

\begin{center}
\begin{figure*}
\center
\subfloat[$u$ error]{\label{uerr}\includegraphics[width=0.33\textwidth]{u_error.png} 
}  
\subfloat[$v$ error]{\label{verr}\includegraphics[width=0.33\textwidth]{v_error.png} 
} 
\caption{Absolute error at $t=0.1$ on a grid of size $N=70$.}
\label{error}
\end{figure*}
\end{center}

\subsection{Convergence test}
A common test is to observe how the solution accuracy increases with decreasing grid spacing.  The rate at which the error decreases is called the convergence rate, also known as the order of accuracy of the solution algorithm.  

Difference schemes have different convergence rates, which can be calculated theoretically.  For example, the forward Euler timestepping used in BINS is first-order, while the spatial differences are second order\footnote{The first derivatives are only second order accurate because of the staggered grid.}.  But what is the order of accuracy of BINS?

We can measure the order of accuracy of our real code using a convergence test.  We solve the same test problem, the Taylor-Green vortex, up to the same time for a range of spatial and time steps.  We calculate the error of our solution, using the known exact solution.  We can now plot the error as a function of the grid spacing/time step (Figure~\ref{conv}).  The order of accuracy of our code is the slope of the best fit line through this plot.  This plot shows the order to be 0.95, which is close to the order 1 predicted by using forward Euler time stepping.

\begin{figure}
\center
\includegraphics[width=.7\textwidth]{conv.png} 
\caption{Order = 0.95}
\label{conv}
\end{figure}


\end{document}








