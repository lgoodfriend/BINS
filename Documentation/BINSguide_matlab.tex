\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{float}
\usepackage{epstopdf}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{sidecap}
\usepackage{subfig}
\usepackage{ulem}
\usepackage{color}
\usepackage[dvips,letterpaper,margin=1in]{geometry} %for one inch margins
\author{Lauren Goodfriend}
\title{Guide to the BINS educational solver}
\begin{document}
\maketitle
\tableofcontents

%----------------------------------------------------------------------
\section{Introduction}
%----------------------------------------------------------------------

The Basic Incompressible Navier-Stokes (BINS) solver is designed to be an educational tool for learning how to solve the incompressible Navier-Stokes equation with finite differences.  A gap exists between the basic numerical methods learned in a numerical partial differential equations class and the complexity of full Navier-Stokes research codes.  BINS is intended to form a bridge for engineering students who have some knowledge of numerical methods, but are unsure how to combine them into a working Navier-Stokes solver.  It may also be useful for students wrestling with an enormous research code for the first time, as a reference for the essential processes underlying most finite difference physical Navier-Stokes solvers.

%----------------------------------------------------------------------
\section{Getting started}
%----------------------------------------------------------------------

BINS is written in Matlab/Octave, so you will need one of those interpreters to run the code.  Octave is a free, open-source language that is very similar to Matlab.  You can learn about it at \texttt{www.gnu.org/software/octave}.

The first step is to download the code tarball from \[ \texttt{https://github.com/lgoodfriend/BINS/downloads}\]  After you've downloaded and untarred the tarball, you should see a folder with a bunch of files in it.  The key file for getting started is \texttt{intro.m}.

Start a Matlab/Octave session and type \texttt{intro} at the prompt.  You should see two figures appear (Figure~\ref{}).  These represent the solution to the Taylor-Green vortex after 1 second.

\subsection{Changing the domain}
The domain size is controlled by \texttt{N} and \texttt{L}.  \texttt{N} sets the number of cells in each direction, and \texttt{L} sets the physical length of each dimension.

\subsection{Changing the boundary conditions}
The boundary conditions are controlled by \texttt{BC}.  \texttt{BC} is a vector with entries corresponding to tags marking the choice of boundary condition:
\[ \texttt{BC} = [\mathrm{lower \hspace{2pt} x, upper\hspace{2pt} x, lower\hspace{2pt} y, upper\hspace{2pt} y} ]\]

BINS has two kinds of boundary conditions
\begin{itemize}
\item periodic
\item moving, impermeable, no-slip wall
\end{itemize}

The periodic boundary conditions are tagged with $\sqrt{-1}$, and the wall boundary conditions are tagged with the velocity of the wall.  Thus, if you wanted an all periodic domain, you would set
\[ \texttt{BC = [sqrt(-1),sqrt(-1),sqrt(-1),sqrt(-1)]}\]
If you wanted the $x$ boundaries to be periodic, with fixed walls on the $y$ boundaries (making an infinite channel), you would set
\[ \texttt{BC = [sqrt(-1),sqrt(-1),0,0]}\]
If you wanted to make a cavity forced by a lid moving at speed $U$ on the upper $y$ boundary, you would set
\[ \texttt{BC = [0,0,0,U]}\]

\subsection{Changing the initial condition}
The initial condition is controlled by \texttt{IC\_choice}, which indexes to an initial condition listed in \texttt{IC.m}.  The available initial conditions are 
\begin{enumerate}
\item $u$ = 0, $v$ = 0, $p$ = 0
\item $u$ = 1, $v$ = 1, $p$ = 0
\item Taylor-Green vortex
\end{enumerate}
You can add a new initial condition by editing \texttt{IC.m} to include the initial condition you would like.  If you are setting a new initial condition, it is important to understand how the staggered grid is set up (see section~\ref{staggeredGrid}).

%----------------------------------------------------------------------
\section{Underlying mathematics}
%----------------------------------------------------------------------

\subsection{Solving the Navier-Stokes equation}
\label{mathBasics}

We want to solve the incompressible Navier-Stokes equation
\begin{align*}
  \left. \underbrace{\frac{\partial u_i}{\partial t}}_\textrm{time} +  \underbrace{\frac{\partial u_i u_j}{\partial x_j}}_\textrm{advection} = \underbrace{- \frac{1}{\rho}\frac{\partial p}{\partial x_i}}_\textrm{pressure} + \underbrace{\nu \frac{\partial^2 u_i}{\partial x_j \partial x_j}}_\textrm{diffusion} \right\} &\textrm{momentum conservation} \\
\left. \frac{\partial u_i}{\partial x_i} = 0 \right\} &\textrm{mass conservation}
\end{align*}

The code first estimates the solution to the Navier-Stokes equation using only the advection and diffusion terms. 
\begin{equation}
 \frac{\partial u_i^*}{\partial t} =   -\frac{\partial u_i^n u_j^n}{\partial x_j} + \nu \frac{\partial^2 u_i^n}{\partial x_j \partial x_j} 
 \label{predict}
\end{equation}
The superscripts $n$ refer to the current, $n^\textrm{th}$ timestep: $u_i^n$ is the $i^\textrm{th}$ component of the velocity at timestep $n$.  The superscript $*$ denotes that the velocity calculated in this step $u^*$ is temporary and doesn't exist at a timestep.

The code then projects the intermediate velocity field $u_i^*$ onto a divergence-free space using the next time step pressure $p^{n+1}$ calculated by
\begin{equation}
\nabla^2 p^{n+1} = \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i}
\label{poisson}
\end{equation}

Then we can find the new divergence free velocity field $u_i^{n+1}$ 

\begin{equation}
u_i^{n+1}= u_i^* - \Delta t\frac{\partial p^{n+1}}{\partial x_i}
\label{correct}
\end{equation}

since
\begin{align*}
\frac{\partial  u_i^{n+1}}{\partial x_i} &= \frac{\partial}{\partial x_i}\left(u_i^* - \Delta t\frac{\partial p^{n+1}}{\partial x_i} \right) \\
&= \frac{\partial u_i^*}{\partial x_i} - \Delta t\nabla^2p^{n+1} \\
&= 0 \\
\end{align*}

These steps appear in the functions in the file \texttt{advance.m}.  In the $\texttt{predict}$ function, the next time step velocity is estimated following equation~\ref{predict}.  This step uses the advection and diffusion terms, calculated in subroutines \texttt{advection} and \texttt{diffusion} respectively.  The poisson equation for pressure in equation~\ref{poisson} is solved in hte function $\texttt{pressure}$.  The next time step velocity is then calculated by correcting the predicted velocity in function \texttt{correct}, as in equation~\ref{correct}.  These steps are outlined below.

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
advection term & $\frac{\partial u_i u_j}{\partial x_j}$ & \texttt{advection} & \texttt{advance.m}\\ 
\hline 
diffusion term & $\nu \frac{\partial^2 u_i}{\partial x_j \partial x_j}$ & \texttt{diffusion} & \texttt{advance.m} \\ 
\hline 
next time step: velocity prediction & $ \frac{\partial u_i^*}{\partial t} =   -\frac{\partial u_i^n u_j^n}{\partial x_j} + \nu \frac{\partial^2 u_i^n}{\partial x_j \partial x_j} $ & \texttt{predict}& \texttt{advance.m} \\ 
\hline 
next time step: pressure & $\nabla^2 p^{n+1} = \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i}$ & \texttt{pressure} & \texttt{advance.m}\\ 
\hline 
next time step: velocity & $u_i^{n+1}= u_i^* - \Delta t\frac{\partial p^{n+1}}{\partial x_i}$ & \texttt{correct}& \texttt{advance.m} \\ 
\hline 
\end{tabular} 
\end{center}

\subsection{Finite differences}

To approximate a partial differential equation on the computer, we use finite differences to estimate derivatives.  BINS uses second order Adams-Bashforth time stepping and second-order centered differences in space.

\subsubsection{Time stepping}
The time stepping in BINS is done using forward Euler time stepping.  If we want to approximate 
\[ \frac{\partial u}{\partial t} = f(u,t) \]
we use the simple approximation
\[ \frac{u^{n+1}-u^n}{\Delta t} = f(u^n,t^n)\]

This allows us to calculate $u$ at the next timestep as
\begin{equation}
u^{n+1} = u^n + \Delta t f(u^n,t^n)
\end{equation}

We use these time stepping routines in the \texttt{predict} function to estimate the next time step velocity using the advection and diffusion terms, without accounting for pressure.  So in BINS
\[ f(u,t) = -\frac{\partial u_i u_j}{\partial x_j} + \nu \frac{\partial^2 u_i}{\partial x_j \partial x_j} \]

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
time step & $\frac{\partial u_i}{\partial t}$ & \texttt{predict}& \texttt{advance.m} \\ 
\hline 
\end{tabular} 
\end{center}

\subsubsection{Spatial derivatives}
To solve the Navier-Stokes equation, we need to calculate first and second derivatives.  BINS uses centered finite differences for all these calculations.  First derivatives are approximated as
\begin{equation}
\label{firstDeriv}
\frac{\partial u_i}{\partial x} = \frac{u_{i+1} - u_{i}}{\Delta x}
\end{equation}
and second derivatives as
\begin{equation}
\label{secondDeriv}
\frac{\partial^2 u}{\partial x^2} = \frac{u_{i+1} -2 u_i + u_{i+1}}{\Delta x^2}
\end{equation}
Subroutines to calculate spatial derivatives are found in the file \texttt{calculus.m}.

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
first derivative & $\frac{\partial u}{\partial x}$ & \texttt{firstDeriv} & \texttt{calculus.m}\\ 
\hline 
second derivative & $\frac{\partial^2 u}{\partial x^2}$ & \texttt{secondDeriv} & \texttt{calculus.m}\\ 
\hline 
\end{tabular} 
\end{center}

\subsection{Solving the Poisson equation}
As we saw in section~\ref{mathBasics}, we must solve a Poisson equation to find the pressure at the next timestep (equation~\ref{poisson}):
\[\nabla^2 p^{n+1} = \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i} \]

Solving a finite difference Poisson equation is actually inverting a matrix.  To see this, we first write the Poisson equation as a finite difference:
\begin{align*}
\nabla^2 p^{n+1} &= \frac{1}{\Delta t}\frac{\partial u_i^*}{\partial x_i} \\
\frac{p_{i+1j}-2p_{ij}+p_{i-1j}}{\Delta x^2} + \frac{p_{ij+1}-2p_{ij}+p_{ij-1}}{\Delta y^2} &= f_{ij}  \\
\end{align*}

We've dropped the superscripts indicating timestep and written the right hand side as $f_{ij}$.  Remember that we know $f_{ij}$ and we need to solve for $p_{ij}$.  Assuming $\Delta x = \Delta y$,
\begin{align*}
\frac{p_{i+1j}-2p_{ij}+p_{i-1j}}{\Delta x^2} + \frac{p_{ij+1}-2p_{ij}+p_{ij-1}}{\Delta x^2} &= f_{ij}  \\
p_{i+1j}-4p_{ij}+p_{i-1j}+ p_{ij+1}+p_{ij-1} &= \Delta x^2 f_{ij}  \\
\end{align*}

By transforming the matrix $p_{ij}$ into a vector, we can convert this into a matrix equation.  For example, consider solving the Poisson equation on a $3 \times 3$ grid:
FIGURE

Write the vector p as
\[ p^{T} = [p_{11}, p_{12}, p_{13}, p_{21}, p_{22}, p_{23}, p_{13}, p_{23}, p_{33}]\]

The row for $p_{22}$ is the simplest, since only points inside the domain are needed to calculate second derivatives at the central point.
\[ \left[ \begin{array}{c c c c c c c c c} \\ \\ \\ \\ 0&1&0&1&-4&1&0&1&0 \\ \\ \\ \\ \\ \end{array} \right] \left[ \begin{array}{c} p_{11}\\p_{12}\\p_{13}\\p_{21}\\p_{22}\\p_{23}\\p_{31}\\p_{32}\\p_{33}\\ \end{array}\right] = \left[ \begin{array}{c} f_{11}\\f_{12}\\f_{13}\\f_{21}\\f_{22}\\f_{23}\\f_{31}\\f_{32}\\f_{33}\\ \end{array}\right]
\]
For all the other points, we know some information, but other information must be filled in using boundary conditions.  If we just filled in the matrix using the finite difference formula as much as possible, we would find
\[ \left[ \begin{array}{c c c c c c c c c} 
-4&1&0&1&0&0&0&0&0\\ 
1&-4&1&0&1&0&0&0&0\\ 
0&1&-4&0&0&1&0&0&0\\ 
1&0&0&-4&1&0&1&0&0\\ 
0&1&0&1&-4&1&0&1&0 \\ 
0&0&1&0&1&-4&0&1&0\\ 
0&0&0&1&0&0&-4&1&0\\ 
0&0&0&0&1&0&1&-4&1\\ 
0&0&0&0&0&1&0&1&-4\\ \end{array} \right] \left[ \begin{array}{c} p_{11}\\p_{12}\\p_{13}\\p_{21}\\p_{22}\\p_{23}\\p_{31}\\p_{32}\\p_{33}\\ \end{array}\right] = \left[ \begin{array}{c} f_{11}\\f_{12}\\f_{13}\\f_{21}\\f_{22}\\f_{23}\\f_{31}\\f_{32}\\f_{33}\\ \end{array}\right]
\]

This matrix equation is incorrect because it does not enforce boundary conditions\footnote{In fact, it does not form a true finite difference approximation to derivatives, since the rows do not all sum to 1.}. For all but the center point, we need boundary conditions to calculate the Laplacian.  

For example, if the boundary conditions are periodic (see section~\ref{periodicBCs}), then $p_{12}$ is adjacent to $p_{32}$, $p_{21}$ is adjacent to $p_{23}$, etc.  Then the matrix is
\[ \left[ \begin{array}{c c c c c c c c c} 
-4&1&1&1&0&0&1&0&0\\ 
1&-4&1&0&1&0&0&1&0\\ 
1&1&-4&0&0&1&0&0&1\\ 
1&0&0&-4&1&1&1&0&0\\ 
0&1&0&1&-4&1&0&1&0 \\ 
0&0&1&1&1&-4&0&1&0\\ 
1&0&0&1&0&0&-4&1&1\\ 
0&1&0&0&1&0&1&-4&1\\ 
0&0&1&0&0&1&1&1&-4\\ \end{array} \right] \left[ \begin{array}{c} p_{11}\\p_{12}\\p_{13}\\p_{21}\\p_{22}\\p_{23}\\p_{31}\\p_{32}\\p_{33}\\ \end{array}\right] = \left[ \begin{array}{c} f_{11}\\f_{12}\\f_{13}\\f_{21}\\f_{22}\\f_{23}\\f_{31}\\f_{32}\\f_{33}\\ \end{array}\right]
\]
We can then solve for the pressure by solving this matrix equation
\[ Ap = f\]
which has solution
\[ p = A^{-1}f\]
In BINS, the matrix $A$ and vector $f$ are formed in \texttt{make\_matrix.m}, and the solution is found in \texttt{solvePoisson.m}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{Component} & \bf{Math} & \bf{Function} & \bf{File}\\ 
\hline 
matrix defining Laplacian & $A$ & \texttt{make\_matrix} & \texttt{make\_matrix.m}\\ 
\hline 
vector defining Poisson forcing & $f$ & \texttt{make\_matrix} & \texttt{make\_matrix.m}\\ 
\hline 
solution to Poisson equation & $p = A^{-1}f$ & \texttt{solvePoisson} & \texttt{solvePoisson.m}\\ 
\hline 
\end{tabular} 
\end{center}

\subsubsection{Inverting a matrix}
Solving the Poisson equation requires inverting a matrix.  Gaussian elimination can invert a matrix, but this algorithm is expensive, in that it takes a lot of computational time.  Many shortcuts have been developed to invert matrices quickly.  These shortcuts often do not solve the inversion exactly, which is ok, because we are only approximating the solution to the Navier-Stokes equations anyway.

This version of BINS uses Matlab/Octave's built in matrix inversion function \texttt{backslash}, also written ``\textbackslash''.  This is admittedly a crutch, but it's a very nice crutch.  Both Matlab and Octave have sparse matrix functions built in, which makes inverting sparse matrices like $A$ very fast.  Solving the Poisson equation is usually the slowest part of a Navier-Stokes solver.

%----------------------------------------------------------------------
\section{Specifics of the computation}
%----------------------------------------------------------------------
\subsection{Staggered grid}
\label{staggeredGrid}
In a standard numerical grid, all the variables are located at cell centers (Figure~\ref{}).  This arrangement is simple to code, but it is not commonly used in Navier-Stokes solvers.  A staggered grid (Figure~\ref{}) is more natural for solving the Navier-Stokes equation, because it increases the order of accuracy of the spatial derivatives involved in solving for the pressure\footnote{This is an oversimplification.  If you want to know the details, look at F\&P}.

\subsection{Boundary conditions}
When we want to calculate a first derivative of $u_j$ ($u$ at spatial point $j$), we require $u_{j+1}$.  If $u_j$ is on an upper boundary, we need to know what to use for $u_{j+1}$ in equation~\ref{firstDeriv}.  The same is true for calculating a second derivative in equation~\ref{secondDeriv}.

BINS uses two kinds of boundary conditions: periodic and moving wall.  Boundary conditions are implemented using "ghost cells" (Figure~\ref{ghostcells}).  Ghost cells are points which lie outside the real solution domain, but are needed to calculate derivatives at the boundaries.  The solution is calculated on the inner domain, and then ghost cells are filled so that derivatives can be taken in the next time step.  Boundary conditions are enforced in \texttt{BCfill.m}.

\subsubsection{Periodic boundary condition}
\label{periodicBCs}
A periodic boundary condition states that opposite edges of the domain are adjacent (Figure~\ref{torus}).  It is called "periodic" because this boundary condition causes the solution to repeat infinitely, so it becomes periodic with a period equal to the length of the domain.

To implement this boundary condition, the solution at the right edge of the domain is copied to the ghost cells on the left edge of the domain, and vice-versa (Figure~\ref{}).  

\subsubsection{Moving wall boundary condition}
A moving wall boundary condition states that the boundary is an impermeable wall that is moving parallel to itself (Figure~\ref{}).  It can also be a stationary wall by setting the wall velocity to zero.

Unlike for the periodic boundary condition, the moving wall boundary condition must treat the two velocities and pressure differently (Figure~\ref{}).  The velocity perpendicular to the wall must be zero at the wall, otherwise fluid would be moving into the wall.  The velocity parallel to the wall must be equal to the wall's velocity at the wall to satisfy the no-slip condition.  The derivative of the pressure perpendicular to the wall must be zero at the wall, otherwise the pressure would generate a force moving fluid into the wall.

The way we structured the grid means that we can set the velocity perpendicular to the wall to be equal to zero, because that velocity has a grid point on the wall (Figure~\ref{}).  The velocity parallel to the wall does not have a grid point on the wall, so we need to interpolate. We have chosen to use a linear interpolation, so we require
\[ \frac{u_1 + u_{\mathrm{ghost}}}{2} = U_{\mathrm{wall}}\]
which means that
\begin{equation}
u_{\mathrm{ghost}} = 2U_{\mathrm{wall}} - u_1
\end{equation}
To set the pressure, we use the approximation to the first derivative in equation~\ref{firstDeriv}, and require
\[ \frac{p_1 - p_{\mathrm{ghost}}}{dx} = 0\]
which means that
\begin{equation}
p_{\mathrm{ghost}} = p_1
\end{equation}

%----------------------------------------------------------------------
\section{BINS reference: by function name}
%----------------------------------------------------------------------
This section provides a function-by-function breakdown of the components that make BINS work.

\includegraphics[width=\textwidth]{callGraph.png} 

\subsection{\texttt{advectionTerm}}
This function estimates the advection term of the Navier Stokes equation.

\subsection{\texttt{BINS}}
The main function is \texttt{BINS}, located in \texttt{BINS.m}.  It takes...  It calls the functions needed to advance the solution in time.

%----------------------------------------------------------------------
\section{BINS reference: by filename}
%----------------------------------------------------------------------
This section provudes a file-by-file breakdown of the components that make BINS work.

\subsection{\texttt{advance.m}}
This file contains the functions needed to advance the solution in time.

\subsection{\texttt{BINS.m}}
This file contains only one function, \texttt{BINS}, the main function of BINS.

%----------------------------------------------------------------------
\section{Known limitations/bugs}
%----------------------------------------------------------------------


%----------------------------------------------------------------------
\section{Validation}
%----------------------------------------------------------------------
We have validated BINS using the Taylor-Green vortex.  This solution is excellent for validating 2D, incompressible Navier-Stokes solvers because it is time-varying , with a fairly complex structure, but still has an exact solution.  
The exact solution on a periodic domain of dimension $[0,2\pi] \times [0,1\pi]$ is
\[ u=\sin (x) \cos (y) F(t)\]
\[ v=-\cos (x) \sin (y) F(t)\]
\[ F(t)=e^{-2\nu t}\]

\subsection{Comparison with exact solution}
For a first check, we can look at the difference between the numerical and exact solution.

\subsection{Convergence test}
A common test is to observe how the solution accuracy increases with decreasing grid spacing.  The rate at which the error decreases is called the convergence rate, also known as the order of accuracy of the solution algorithm.  

Difference schemes have different convergence rates, which can be calculated theoretically.  For example, the forward Euler timestepping used in BINS is first-order, while the spatial differences are second order\footnote{The first derivatives are only second order accurate because of the staggered grid.}.  But what is the order of accuracy of BINS?

We can measure the order of accuracy of our real code using a convergence test.  We solve the same test problem, the Taylor-Green vortex, up to the same time for a range of spatial and time steps.  We calculate the error of our solution, using the known exact solution.  We can now plot the error as a function of the grid spacing/time step.  The order of accuracy of our code is the slope of the best fit line through this plot.

\includegraphics[width=\textwidth]{convergence.png} 
order = 0.73

\subsection{Error over time}  
We also want to know how much error accumulates as the solution progresses in time.  We can measure this by calculating the error at each timestep for a given resolution, and plotting the results.


\end{document}








